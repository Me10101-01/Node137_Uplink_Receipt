#!/bin/bash
#
# SovereignGuard Phase 1: Vault Setup Script
# Version: 1.0
# Node: 137
# Purpose: Deploy HashiCorp Vault to Kubernetes cluster
#
# Prerequisites:
#   - kubectl configured with cluster access
#   - helm v3 installed
#   - Sufficient cluster permissions
#
# Usage:
#   ./phase1-vault-setup.sh [--dry-run]
#

set -euo pipefail

# Configuration
NAMESPACE="vault"
RELEASE_NAME="vault"
CHART_VERSION="0.27.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${SCRIPT_DIR}/../config"
DRY_RUN=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Banner
print_banner() {
    echo ""
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║           SovereignGuard Phase 1: Vault Setup                  ║"
    echo "║                       Node 137                                 ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"
    echo ""
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check kubectl
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl not found. Please install kubectl first."
        exit 1
    fi
    
    # Check helm
    if ! command -v helm &> /dev/null; then
        log_error "helm not found. Please install helm v3 first."
        exit 1
    fi
    
    # Check cluster connection
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster. Check your kubeconfig."
        exit 1
    fi
    
    log_success "Prerequisites check passed."
}

# Display cluster info
show_cluster_info() {
    log_info "Current cluster context:"
    kubectl config current-context
    echo ""
    log_info "Cluster nodes:"
    kubectl get nodes
    echo ""
}

# Confirm with user
confirm_proceed() {
    if [ "$DRY_RUN" = true ]; then
        log_warn "DRY RUN MODE - No changes will be made"
        return 0
    fi
    
    echo ""
    read -p "Proceed with Vault installation? (y/N): " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_warn "Installation cancelled."
        exit 0
    fi
}

# Add Helm repository
add_helm_repo() {
    log_info "Adding HashiCorp Helm repository..."
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would add hashicorp helm repo"
        return 0
    fi
    
    helm repo add hashicorp https://helm.releases.hashicorp.com 2>/dev/null || true
    helm repo update
    log_success "Helm repository added/updated."
}

# Create namespace
create_namespace() {
    log_info "Creating namespace: ${NAMESPACE}..."
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would create namespace ${NAMESPACE}"
        return 0
    fi
    
    if kubectl get namespace "${NAMESPACE}" &> /dev/null; then
        log_warn "Namespace ${NAMESPACE} already exists."
    else
        kubectl create namespace "${NAMESPACE}"
        kubectl label namespace "${NAMESPACE}" \
            app.kubernetes.io/name=vault \
            app.kubernetes.io/part-of=sovereignguard \
            strategickhaos.ai/node=137
        log_success "Namespace created."
    fi
}

# Generate values file
generate_values() {
    log_info "Generating Helm values file..."
    
    local values_file="/tmp/vault-values.yaml"
    
    cat > "${values_file}" << 'EOF'
# Vault Helm Values for SovereignGuard
# Generated by phase1-vault-setup.sh

global:
  enabled: true
  tlsDisable: false

injector:
  enabled: true
  replicas: 1
  
  resources:
    requests:
      memory: 256Mi
      cpu: 250m
    limits:
      memory: 512Mi
      cpu: 500m

server:
  enabled: true
  
  # Dev mode for initial testing - CHANGE FOR PRODUCTION
  dev:
    enabled: true
    devRootToken: "root"
  
  # Resource configuration
  resources:
    requests:
      memory: 256Mi
      cpu: 250m
    limits:
      memory: 512Mi
      cpu: 500m
  
  # Readiness/Liveness probes
  readinessProbe:
    enabled: true
    path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
  
  livenessProbe:
    enabled: true
    path: "/v1/sys/health?standbyok=true"
    initialDelaySeconds: 60
  
  # Audit log configuration
  auditStorage:
    enabled: true
    size: 5Gi
  
  # Data storage
  dataStorage:
    enabled: true
    size: 10Gi
  
  # Service configuration
  service:
    enabled: true
    type: ClusterIP
    port: 8200
    targetPort: 8200
  
  # HA configuration (commented out for dev mode)
  # ha:
  #   enabled: true
  #   replicas: 3
  #   raft:
  #     enabled: true
  #     setNodeId: true

# UI Configuration
ui:
  enabled: true
  serviceType: ClusterIP
  
  # Enable for external access
  # serviceType: LoadBalancer
  
  # Ingress configuration
  # ingress:
  #   enabled: true
  #   hosts:
  #     - host: vault.strategickhaos.ai
  #       paths: []

# CSI Provider (for secret injection)
csi:
  enabled: false

# Server annotations
serverTelemetry:
  prometheusOperator: false
  
EOF

    log_success "Values file generated at ${values_file}"
    echo "${values_file}"
}

# Install Vault
install_vault() {
    log_info "Installing Vault..."
    
    local values_file=$(generate_values)
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would install Vault with:"
        log_info "  - Namespace: ${NAMESPACE}"
        log_info "  - Release: ${RELEASE_NAME}"
        log_info "  - Chart version: ${CHART_VERSION}"
        log_info ""
        log_info "Dry run Helm output:"
        helm install "${RELEASE_NAME}" hashicorp/vault \
            --namespace "${NAMESPACE}" \
            --version "${CHART_VERSION}" \
            --values "${values_file}" \
            --dry-run
        return 0
    fi
    
    # Check if already installed
    if helm list -n "${NAMESPACE}" | grep -q "${RELEASE_NAME}"; then
        log_warn "Vault release already exists. Upgrading..."
        helm upgrade "${RELEASE_NAME}" hashicorp/vault \
            --namespace "${NAMESPACE}" \
            --version "${CHART_VERSION}" \
            --values "${values_file}"
    else
        helm install "${RELEASE_NAME}" hashicorp/vault \
            --namespace "${NAMESPACE}" \
            --version "${CHART_VERSION}" \
            --values "${values_file}"
    fi
    
    log_success "Vault installed."
}

# Wait for Vault to be ready
wait_for_vault() {
    log_info "Waiting for Vault to be ready..."
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would wait for Vault pods"
        return 0
    fi
    
    local retries=30
    local count=0
    
    while [ $count -lt $retries ]; do
        if kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name=vault -o jsonpath='{.items[*].status.phase}' | grep -q "Running"; then
            log_success "Vault pod is running."
            break
        fi
        count=$((count + 1))
        log_info "Waiting for Vault pod... (${count}/${retries})"
        sleep 10
    done
    
    if [ $count -eq $retries ]; then
        log_error "Timeout waiting for Vault to be ready."
        exit 1
    fi
    
    # Additional wait for Vault to be fully initialized
    sleep 5
}

# Configure secret engines
configure_secret_engines() {
    log_info "Configuring secret engines..."
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would configure secret engines:"
        log_info "  - KV v2 at kv/"
        log_info "  - SSH at ssh/"
        log_info "  - PKI at pki/"
        log_info "  - Transit at transit/"
        return 0
    fi
    
    # Get the Vault pod name
    local vault_pod=$(kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name=vault -o jsonpath='{.items[0].metadata.name}')
    
    # Enable KV v2
    log_info "Enabling KV v2 secret engine..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault secrets enable -path=kv kv-v2 2>/dev/null || log_warn "KV engine may already be enabled"
    
    # Enable SSH
    log_info "Enabling SSH secret engine..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault secrets enable -path=ssh ssh 2>/dev/null || log_warn "SSH engine may already be enabled"
    
    # Enable PKI
    log_info "Enabling PKI secret engine..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault secrets enable -path=pki pki 2>/dev/null || log_warn "PKI engine may already be enabled"
    
    # Enable Transit
    log_info "Enabling Transit secret engine..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault secrets enable -path=transit transit 2>/dev/null || log_warn "Transit engine may already be enabled"
    
    log_success "Secret engines configured."
}

# Create policies
create_policies() {
    log_info "Creating Vault policies..."
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would create policies:"
        log_info "  - queen-app-policy"
        log_info "  - swarm-runner-policy"
        return 0
    fi
    
    local vault_pod=$(kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name=vault -o jsonpath='{.items[0].metadata.name}')
    
    # Queen App Policy
    log_info "Creating queen-app-policy..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- sh -c 'cat > /tmp/queen-app-policy.hcl << EOF
# Queen App Policy
path "kv/data/queen-app/*" {
  capabilities = ["read", "list"]
}

path "kv/metadata/queen-app/*" {
  capabilities = ["read", "list"]
}
EOF
vault policy write queen-app-policy /tmp/queen-app-policy.hcl'
    
    # Swarm Runner Policy
    log_info "Creating swarm-runner-policy..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- sh -c 'cat > /tmp/swarm-runner-policy.hcl << EOF
# Swarm Runner Policy
path "kv/data/swarm-runners/*" {
  capabilities = ["read"]
}

path "ssh/sign/runner-role" {
  capabilities = ["create", "update"]
}
EOF
vault policy write swarm-runner-policy /tmp/swarm-runner-policy.hcl'
    
    log_success "Policies created."
}

# Create initial secret structure
create_secret_structure() {
    log_info "Creating initial secret structure..."
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would create secret paths:"
        log_info "  - kv/queen-app/config"
        log_info "  - kv/swarm-runners/config"
        log_info "  - kv/registry/config"
        return 0
    fi
    
    local vault_pod=$(kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name=vault -o jsonpath='{.items[0].metadata.name}')
    
    # Create placeholder secrets (to be updated with real values later)
    log_info "Creating placeholder for queen-app secrets..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault kv put kv/queen-app/config \
        github_app_id="PLACEHOLDER" \
        github_webhook_secret="PLACEHOLDER" \
        github_client_id="PLACEHOLDER" \
        github_client_secret="PLACEHOLDER"
    
    log_info "Creating placeholder for swarm-runners secrets..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault kv put kv/swarm-runners/config \
        runner_registration_token="PLACEHOLDER"
    
    log_info "Creating placeholder for registry secrets..."
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault kv put kv/registry/config \
        username="PLACEHOLDER" \
        password="PLACEHOLDER" \
        server="PLACEHOLDER"
    
    log_success "Secret structure created. Update with real values."
}

# Display Vault status
show_vault_status() {
    log_info "Vault status:"
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY RUN] Would show Vault status"
        return 0
    fi
    
    echo ""
    kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name=vault
    echo ""
    kubectl get svc -n "${NAMESPACE}"
    echo ""
    
    local vault_pod=$(kubectl get pods -n "${NAMESPACE}" -l app.kubernetes.io/name=vault -o jsonpath='{.items[0].metadata.name}')
    kubectl exec -n "${NAMESPACE}" "${vault_pod}" -- vault status 2>/dev/null || true
}

# Print next steps
print_next_steps() {
    echo ""
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║                        Next Steps                              ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"
    echo ""
    echo "1. Update placeholder secrets with real values:"
    echo "   vault kv put kv/queen-app/config github_app_id=\"YOUR_APP_ID\" ..."
    echo ""
    echo "2. Configure Kubernetes auth method:"
    echo "   vault auth enable kubernetes"
    echo ""
    echo "3. Create service accounts for applications to use Vault"
    echo ""
    echo "4. Update Queen App to read secrets from Vault"
    echo ""
    echo "5. Add Vault health check to swarm-core workflows"
    echo ""
    echo "For more information, see: sovereignguard/docs/ARCHITECTURE.md"
    echo ""
}

# Main execution
main() {
    print_banner
    check_prerequisites
    show_cluster_info
    confirm_proceed
    add_helm_repo
    create_namespace
    install_vault
    wait_for_vault
    configure_secret_engines
    create_policies
    create_secret_structure
    show_vault_status
    print_next_steps
    
    echo ""
    log_success "Phase 1 Vault setup complete!"
    echo ""
}

# Run main
main
